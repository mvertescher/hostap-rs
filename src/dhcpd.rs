//! dhcpd management

use std::fs::File;
use std::io::prelude::*;
use std::net::Ipv4Addr;
use std::path::PathBuf;
use std::process::Command;
use std::str::FromStr;

use crate::core;

use log::*;

#[derive(Debug)]
pub struct Config {
    /// String to be appended to the top of the configuration file
    header: String,
    domain_name: String,
    default_lease_time: usize,
    max_lease_time: usize,
    subnet: Ipv4Addr,
    host: Ipv4Addr,
    subnet_mask: Ipv4Addr,
    dns_servers: Vec<Ipv4Addr>,
    min_range: Ipv4Addr,
    max_range: Ipv4Addr,
}

impl Default for Config {
    fn default() -> Config {
        Config {
            header: "# This file has been auto-generated by hostap".to_string(),
            domain_name: "user.lan".to_string(),
            default_lease_time: 3600,
            max_lease_time: 7200,
            subnet: Ipv4Addr::new(10, 1, 1, 0),
            host: Ipv4Addr::new(10, 1, 1, 1),
            subnet_mask: Ipv4Addr::new(255, 255, 255, 0),
            dns_servers: get_host_dns_servers(),
            min_range: Ipv4Addr::new(10, 1, 1, 10),
            max_range: Ipv4Addr::new(10, 1, 1, 100),
        }
    }
}

impl Config {
    /// Convert the configuration to a string.
    fn serialize(self) -> String {
        let mut string = String::new();
        string.push_str(&format!("{}\n\n", &self.header));
        string.push_str(&format!("option domain-name \"{}\";\n", self.domain_name));
        string.push_str(&format!("default-lease-time {};\n", self.default_lease_time));
        string.push_str(&format!("max-lease-time {};\n", self.max_lease_time));
        string.push_str("authoritative;\n\n");

        // Write the subnet configuration
        string.push_str(&format!("subnet {} netmask {} {{\n", self.subnet, self.subnet_mask));
        string.push_str(&format!("  option routers {};\n", self.host));
        string.push_str(&format!("  option subnet-mask {};\n", self.subnet_mask));
        string.push_str(&format!("  option domain-search \"{}\";\n", self.domain_name));

        string.push_str(&format!("  option domain-name-servers\n "));
        for dns_server in self.dns_servers {
            string.push_str(&format!(" {},", dns_server));
        }
        string.pop();  // Remove final ','
        string.push_str(&format!(";\n"));

        string.push_str(&format!("  range {} {};\n", self.min_range, self.max_range));
        string.push_str("}\n");

        string
    }

    /// Write the configuration to a file.
    pub fn to_file(self, path: &PathBuf) {
        let mut file = File::create(path)
            .expect("failed to create file");
        file.write_all(self.serialize().as_ref()).unwrap();
    }
}

/// Get the host's configured dns servers from resolv.conf
fn get_host_dns_servers() -> Vec<Ipv4Addr> {
    let path = PathBuf::from("/etc/resolv.conf");
    let file = File::open(path)
        .expect("failed to open file");
    let file = ::std::io::BufReader::new(&file);
    let mut servers: Vec<Ipv4Addr> = Vec::new();
    for line in file.lines() {
        let line = line.unwrap();
        let mut split = line.split(" ");
        match split.next() {
            Some(s) => {
                if s != "nameserver" {
                    continue;
                }
            },
            None => continue,
        }
        match split.next() {
            Some(s) => servers.push(Ipv4Addr::from_str(s).unwrap()),
            None => continue,
        }
    }
    servers
}

/// Start dhcpd on the specified interface
pub fn up(interface: &str) {
    let config_path = PathBuf::from("/etc/dhcp/wlan-dhcpd.conf");
    ::std::fs::create_dir_all(config_path.parent().unwrap()).unwrap();

    let config = Config::default();
    info!("{:#?}", config);
    let host_ip = config.host;
    config.to_file(&config_path);

    info!("Assigning interface {} IP address to {}", interface, host_ip);
    Command::new("ip")
        .args(&["addr", "add", &format!("{}/24", host_ip), "dev", interface])
        .output()
        .expect("failed to execute process");

    info!("Starting dhcpd");
    let _child = Command::new("dhcpd")
        .args(&["-f", "-d", "-cf", config_path.to_str().unwrap(), interface])
        .stdout(::std::process::Stdio::null())
        .stderr(::std::process::Stdio::null())
        .spawn()
        .expect("failed to execute child");
}

/// Tear down dhcpd
pub fn down() {
    core::pkill("dhcpd");
}
